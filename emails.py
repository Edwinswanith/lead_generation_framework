import os
import re
import smtplib
import time
import csv
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from datetime import datetime, timedelta
import json
import pandas as pd
from dotenv import load_dotenv
import asyncio
import eventlet
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from agent.sub_agents.agent import create_email_sequence_agent

APP_NAME = "email_content_app"
USER_ID = "email_user"

def check_company_cooldown(company_name: str, summary_path: str) -> bool:
    """
    Check if the company is within the 3-day cooldown period.
    Returns True if company can be emailed (cooldown expired), False otherwise.
    """
    if not os.path.exists(summary_path):
        return True

    try:
        df = pd.read_csv(summary_path)
        if df.empty:
            return True

        # Get all rows for this company
        company_emails = df[df['Company Name'] == company_name]
        if company_emails.empty:
            return True

        # Get the most recent email date
        sent_dates = []
        for col in ['1st Email Sent', '2nd Email Sent', '3rd Email Sent']:
            dates = company_emails[col].dropna()
            if not dates.empty:
                sent_dates.extend(dates.tolist())

        if not sent_dates:
            return True

        # Convert dates to datetime objects
        sent_dates = [datetime.strptime(date, '%Y-%m-%d %H:%M:%S') for date in sent_dates if date.strip()]
        if not sent_dates:
            return True

        last_sent = max(sent_dates)
        cooldown_period = timedelta(days=3)
        return datetime.now() - last_sent >= cooldown_period

    except Exception as e:
        print(f"Error checking cooldown: {e}")
        return True  # If there's an error reading the file, allow sending to be safe

async def generate_email_content(company_data: dict) -> tuple[str, str]:
    """Generate email content using the email content agent."""
    try:
        sess_svc = InMemorySessionService()
        agent = create_email_sequence_agent()
        
        # Load environment variables for sender info
        load_dotenv()
        sender_name = os.getenv("SENDER_NAME", "Bizzzup Team")
        sender_role = os.getenv("SENDER_ROLE", "Business Development & Strategic Partnerships")
        
        # Create initial state with company data and sender info
        initial_state = {
            "company_name": company_data.get('company_name', ''),
            "ceo_name": company_data.get('ceo_name', ''),
            "service_focus": company_data.get('service_focus', ''),
            "target_industries": company_data.get('target_industries', ''),
            "client_examples": company_data.get('client_examples', ''),
            "email": company_data.get('email', ''),
            "sender_name": sender_name,
            "sender_role": sender_role
        }
        
        session_data = await sess_svc.create_session(
            app_name=APP_NAME,
            user_id=USER_ID,
            session_id=str(time.time()),
            state=initial_state
        )

        runner = Runner(agent=agent, app_name=APP_NAME, session_service=sess_svc)
        content = None

        # Create message using google.genai.types.Content
        from google.genai import types
        message = types.Content(
            role="user",
            parts=[types.Part(text="Generate email content")]
        )

        try:
            async for ev in runner.run_async(
                user_id=USER_ID,
                session_id=session_data.id,
                new_message=message
            ):
                if ev.is_final_response() and ev.content and ev.content.parts:
                    content = ev.content.parts[0].text
                    break

            if not content:
                print("No content generated by the agent")
                return None, None

            # Extract JSON from code block if present
            if '```json' in content:
                content = content.split('```json')[1].split('```')[0].strip()
            elif '```' in content:
                content = content.split('```')[1].split('```')[0].strip()

            content_json = json.loads(content)
            subject = content_json.get("subject")
            body = content_json.get("body")
            
            if not subject or not body:
                print("Missing subject or body in generated content")
                return None, None
                
            return subject, body

        except json.JSONDecodeError as e:
            print(f"Error parsing agent response as JSON: {e}")
            print(f"Raw content: {content}")
            return None, None
        finally:
            # Clean up the runner and its resources
            try:
                if hasattr(runner, '_client') and runner._client is not None:
                    await runner._client.aclose()
            except Exception as e:
                print(f"Error closing runner client: {e}")
            
    except Exception as e:
        print(f"Error generating email content: {e}")
        return None, None

async def send_emails_task(session_id: str, companies_path: str, mode: str, socketio, app):
    """Background task to send emails."""
    try:
        load_dotenv()
        sender_email = os.getenv("SENDER_EMAIL", "sender@bizzzup.com")
        sender_password = os.getenv("SENDER_PASSWORD")
        sender_name = os.getenv("SENDER_NAME", "Bizzzup Team")
        sender_role = os.getenv("SENDER_ROLE", "Business Development & Strategic Partnerships")

        # Create session directory in files folder
        session_dir = os.path.join(app.config['BASE_DIR'], 'files', session_id)
        os.makedirs(session_dir, exist_ok=True)

        # Read the CSV file
        try:
            df = pd.read_csv(companies_path)
        except Exception as e:
            socketio.emit('email_progress', {
                'status': {
                    'success': False,
                    'message': f'Error reading CSV file: {str(e)}',
                    'company_name': 'System'
                }
            }, room=session_id)
            return

        # Define the email column - check both CEO Email and Email columns
        email_column = next((col for col in df.columns if col in ['CEO Email', 'Email']), None)
        if not email_column:
            socketio.emit('email_progress', {
                'status': {
                    'success': False,
                    'message': 'No email column found in the CSV file',
                    'company_name': 'System'
                }
            }, room=session_id)
            return

        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

        if mode == 'send' and (not sender_email or not sender_password):
            socketio.emit('email_progress', {
                'status': {
                    'success': False,
                    'message': 'Email credentials not configured in environment',
                    'company_name': 'System'
                }
            }, room=session_id)
            return

        # Get all rows with valid emails
        valid_rows = []
        for index, row in df.iterrows():
            email = str(row.get(email_column, '')).strip()
            if email and re.match(email_pattern, email):
                valid_rows.append((index, row))

        total_emails = len(valid_rows)

        if total_emails == 0:
            socketio.emit('email_progress', {
                'status': {
                    'success': False,
                    'message': 'No valid email addresses found in the data',
                    'company_name': 'System'
                }
            }, room=session_id)
            return

        processed_count = 0
        skipped_count = 0
        
        # Create or open summary CSV file in the session directory
        summary_path = os.path.join(session_dir, 'email_summary.csv')
        summary_exists = os.path.exists(summary_path)
        
        with open(summary_path, 'a', newline='') as f:
            writer = csv.writer(f)
            if not summary_exists:
                writer.writerow(['Company Name', 'Email', 'CEO Name', 'Subject', '1st Email Sent', '2nd Email Sent', '3rd Email Sent'])
        
        # Emit initial progress
        socketio.emit('email_progress', {
            'progress': {
                'sent': 0,
                'total': total_emails,
                'action': mode
            }
        }, room=session_id)
        
        # Process all valid emails
        for index, row in valid_rows:
            try:
                company_data = {
                    'company_name': str(row.get('Company Name', '')),
                    'ceo_name': str(row.get('CEO Name', '')),
                    'service_focus': str(row.get('Service Focus', '')),
                    'target_industries': str(row.get('Target Industries', '')),
                    'client_examples': str(row.get('Client Examples', '')),
                    'email': str(row.get(email_column, '')).strip(),
                    'sender_name': sender_name,
                    'sender_role': sender_role
                }

                # Check cooldown period
                if not check_company_cooldown(company_data['company_name'], summary_path):
                    skipped_count += 1
                    status_msg = 'Skipped - Company in cooldown period'
                    socketio.emit('email_progress', {
                        'status': {
                            'success': True,
                            'message': status_msg,
                            'company_name': company_data['company_name'],
                            'email': company_data['email']
                        }
                    }, room=session_id)
                    continue

                # Generate email content using the agent
                subject, body = await generate_email_content(company_data)
                
                if not subject or not body:
                    raise Exception("Failed to generate email content")

                # Create email message
                msg = MIMEMultipart('alternative')
                msg['Subject'] = subject
                msg['From'] = f"{sender_name} <{sender_email}>"
                msg['To'] = company_data['email']
                msg.attach(MIMEText(body, 'html'))

                sent_time = ""
                status_msg = 'Email prepared'

                # If mode is 'send', send the email
                if mode == 'send':
                    try:
                        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
                            server.login(sender_email, sender_password)
                            server.send_message(msg)
                            sent_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                            status_msg = 'Email sent successfully'
                    except Exception as e:
                        print(f"SMTP Error: {str(e)}")
                        status_msg = f'Failed to send email: {str(e)}'

                # Update summary CSV
                with open(summary_path, 'a', newline='') as f:
                    writer = csv.writer(f)
                    writer.writerow([
                        company_data['company_name'],
                        company_data['email'],
                        company_data['ceo_name'],
                        subject,
                        sent_time,  # 1st Email sent time
                        "",        # 2nd Email (not sent yet)
                        ""         # 3rd Email (not sent yet)
                    ])

                processed_count += 1

                # Emit progress update
                socketio.emit('email_progress', {
                    'progress': {
                        'sent': processed_count,
                        'total': total_emails - skipped_count,
                        'action': mode
                    },
                    'status': {
                        'success': bool(sent_time),
                        'message': status_msg,
                        'company_name': company_data['company_name'],
                        'email': company_data['email']
                    }
                }, room=session_id)

                # Add a small delay between emails
                await asyncio.sleep(1)

            except Exception as e:
                print(f"Error processing email for {company_data['company_name']}: {str(e)}")
                socketio.emit('email_progress', {
                    'status': {
                        'success': False,
                        'message': f'Error processing email for {company_data["company_name"]}: {str(e)}',
                        'company_name': company_data['company_name']
                    }
                }, room=session_id)

        # Final status update
        socketio.emit('email_progress', {
            'progress': {
                'sent': processed_count,
                'total': total_emails - skipped_count,
                'action': mode
            },
            'status': {
                'success': True,
                'message': f'Completed processing {processed_count} emails ({skipped_count} skipped due to cooldown)',
                'company_name': 'System',
                'summary_file': summary_path
            }
        }, room=session_id)
    except Exception as e:
        print(f"Error in send_emails_task: {e}")
        socketio.emit('email_progress', {
            'status': {
                'success': False,
                'message': f'Error in email task: {str(e)}',
                'company_name': 'System'
            }
        }, room=session_id)